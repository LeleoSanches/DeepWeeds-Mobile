import tensorflow as tf
import pandas as pd

import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing import image_dataset_from_directory
from tensorflow.keras.utils import image_dataset_from_directory
import os
from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import matplotlib.pyplot as plt
from tensorflow.keras.applications import mobilenet_v3
from tensorflow.keras.applications import MobileNetV3Large

# Global - Paths
IMG_DIR = "/home/leo/Documentos/DeepWeeds-master/images/"
LABEL_DIR = "/home/leo/Documentos/DeepWeeds-master/labels/"


# Global - Parâmetros
BATCH_SIZE = 32
IMG_SIZE = (224, 224)
RAW_IMG_SIZE = (256,256)
INPUT_SHAPE = (224,224,3)
CLASSES = [0, 1, 2, 3, 4, 5, 6, 7, 8]
#AUTOTUNE = tf.data.AUTOTUNE


data = pd.read_csv(LABEL_DIR + "labels.csv")
data['Label'] = data["Label"].astype(str)
data['Filename'] = data['Filename'].apply(lambda x: os.path.join(IMG_DIR, x))
df_train, df_val = train_test_split(data, test_size=0.2, stratify=data['Label'], random_state=42)




def crop(img, size):
    """
    Crop the image concentrically to the desired size.
    :param img: Input image
    :param size: Required crop image size
    :return:
    """
    (h, w, c) = img.shape
    x = int((w - size[0]) / 2)
    y = int((h - size[1]) / 2)
    return img[y:(y + size[1]), x:(x + size[0]), :]


def crop_generator(batches, size):
    """
    Take as input a Keras ImageGen (Iterator) and generate random
    crops from the image batches generated by the original iterator
    :param batches: Batches of images to be cropped
    :param size: Size to be cropped to
    :return:
    """
    while True:
        batch_x, batch_y = next(batches)
        (b, h, w, c) = batch_x.shape
        batch_crops = np.zeros((b, size[0], size[1], c))
        for i in range(b):
            batch_crops[i] = crop(batch_x[i], (size[0], size[1]))
        yield (batch_crops, batch_y)

train_datagen = ImageDataGenerator(
    rescale=1./255
)
"""
train_datagen = ImageDataGenerator(
    rescale=1. / 255,
    fill_mode="constant",
    shear_range=0.2,
    zoom_range=(0.5, 1),
    horizontal_flip=True,
    rotation_range=360,
    channel_shift_range=25,
    brightness_range=(0.75, 1.25))
"""

# Gerador para treino
train_generator = train_datagen.flow_from_dataframe(
    dataframe=df_train,
    directory = None,
    x_col="Filename",
    y_col="Label",
    color_mode = "rgb",
    target_size=RAW_IMG_SIZE,
    batch_size=BATCH_SIZE,
    classes=CLASSES,
    class_mode="categorical",
    validade_filenames = True,
    subset="training",
    save_format = "jpeg"
)

# Gerador para validação
val_generator = train_datagen.flow_from_dataframe(
    dataframe=df_val,
    x_col="Filename",
    y_col="Label",
    target_size=RAW_IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode="categorical",
    subset="validation",
    has_ext=True,
    classes=CLASSES,
    shuffle=False
)

train_generator = crop_generator(train_data_generator, IMG_SIZE)
val_generator = crop_generator(val_data_generator, IMG_SIZE)
"""
##MODEL
### MOBILENETV2
base_model = MobileNetV2(input_shape=IMG_SIZE + (3,), include_top=False, weights='imagenet')
base_model.trainable = False  # Congela a base inicialmente
"""

##MOBILENETV3LARGE
"""

include_top = False

tf.keras.applications.mobilenet_v2.preprocess_input

1 - Garantir que a Função de Preprocess do modelo está conforme

preprocess = mobilenet_v3.preprocess_input

def preprocess_map(x, y):
    x = preprocess(x)
    return x, y

"""


"""

preprocess = mobilenet_v3.preprocess_input

def preprocess_map(x, y):
    x = preprocess(x)
    return x, y

base_model = mobilenet_v3.MobileNetV3Large(
    input_shape=(224, 224, 3),
    include_top=False,
    weights='imagenet',
    alpha = 1.0
)
"""
"""base_model = MobileNetV3Large(
    input_shape=(224, 224, 3),
    include_top=False,
    weights='imagenet'
)"""
base_model = MobileNetV2(input_shape=IMG_SIZE + (3,), include_top=False, weights='imagenet')

data_augmentation = tf.keras.Sequential([
    layers.RandomResizedCrop(IMG_SIZE, IMG_SIZE, scale=(0.7, 1.0), ratio=(0.75, 1.33)),
    layers.RandomFlip("horizontal"),
    layers.RandomBrightness(0.1),
    layers.RandomContrast(0.1),
])


base_model.trainable = False

##Augmentation

inputs = layers.Input((IMG_SIZE, IMG_SIZE, 3))
x = data_augmentation(inputs)


##Transfer
x = preprocess(x)
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = layers.Dropout(0.2)(x)
#x = Dense(128, activation='relu')(x)
outputs = Dense(len(CLASSES), activation='sigmoid')(x)

model = models.Model(inputs=inputs, outputs=outputs)

"""
loss = "sparse_categorical_crossentropy


loss='categorical_crossentropy'
"""

model.compile(
    optimizer=Adam(learning_rate=0.001),
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)



history = model.fit(
    train_generator,
    validation_data=val_generator,
    epochs=150)



def plot_history(history, save_path):
    plt.figure(figsize=(12, 5))

    # Acurácia
    plt.subplot(1, 2, 1)
    plt.plot(history.history['accuracy'], label='Treino')
    plt.plot(history.history['val_accuracy'], label='Validação')
    plt.title('Acurácia por época')
    plt.xlabel('Época')
    plt.ylabel('Acurácia')
    plt.legend()

    # Loss
    plt.subplot(1, 2, 2)
    plt.plot(history.history['loss'], label='Treino')
    plt.plot(history.history['val_loss'], label='Validação')
    plt.title('Loss por época')
    plt.xlabel('Época')
    plt.ylabel('Loss')
    plt.legend()

    plt.tight_layout()
    plt.show()

    plt.savefig(save_path)
    print(f"Gráfico salvo em: {save_path}")

    plt.show()


final_metrics = {
    "final_train_acc": history.history['accuracy'][-1],
    "final_val_acc": history.history['val_accuracy'][-1],
    "final_train_loss": history.history['loss'][-1],
    "final_val_loss": history.history['val_loss'][-1]
}

print(final_metrics)



df_metrics = pd.DataFrame(history.history)
df_metrics.to_csv("historico_treinamento.csv", index=False)

plot_history(history, save_path='treinamento_mobilenetV3Small.png')